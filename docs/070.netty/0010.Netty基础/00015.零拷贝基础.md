# 零拷贝

为什么需要零拷贝，因为我们正常的网络传输，是要经过read()从磁盘中读到用户态， + write()从用户态写到网卡发出去，这两步的。这两步需要4次的内存拷贝，2次的系统调用。

2次系统调用就意味着需要4次的上下文切换，让我们来看看

## read + write
4次上下文切换+4次内存拷贝
![image](./read-write.png)

## mmap + write
内存映射也要经过2次的系统调用，但是减少了一次内核态到用户态的内存拷贝

4次上下文切换+3次内存拷贝
![image](./mmap-write.png)

## sendfile
sendfile只有一次系统调用

2次上下文切换+3次拷贝
![image](./sendfile.png)

## sendfile + SGDMA
彻底的零拷贝，有SGDMA的话，就可以不用在内核态再拷贝了。
![image](./sendfile_SGDMA.png)

## pagecache
在零拷贝中会使用到pagecache，他是一种内存缓存策略和mysql中的buffer poll类似。

因为我们知道磁盘读写到内存是很慢的，所以我们更期望是它就在内存中，我们读写就会很快。那么就会把一些磁盘中的文件保存在pagecache当中，并且pagecache支持预读，也就是读32bit的时候，会把接下来的32bit也读一些，这样可以有效提升缓存的命中率。

## 大文件传输
当有大文件传输的时候，pagecache就失效了，因为大文件占据了pagecache的空间，它几乎不会命中，而我们每次从磁盘里读取出数据来以后还需要去往pagecache拷贝一份，这样简直是浪费咯。所以大文件传输的时候就不该用使用pagecache的零拷贝。我们要使用直接读取的异步IO。

那么读写策略我们就已经得出:
1. 小文件使用零拷贝
2. 大文件使用异步IO+直接读取