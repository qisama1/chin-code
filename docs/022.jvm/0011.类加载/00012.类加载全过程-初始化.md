# 类加载全过程-初始化

此时已经经过了加载和连接，那么已经找到了对应的类的信息了。
在java8之前，static变量是放在方法区中的，但在java8之后会随着class对象一起放在java堆中。而实例对象的话并不会在这里有啥反应，因为它只会在实例化的时候才会分配在内存中。

## clinit
此时初始化就是执行clinit方法，它收集了static变量的初始化以及static{}代码块。
clinit也是我们程序员能够干预到的东西了。

同时与init方法不同，init会显示调用父类的init方法，clinit则是保证在clinit之前父类的clinit已经执行过了。所以第一个进行clinit一定是java.lang.Object.
而且只有静态的东西才会经历clinit。

## 接口的clinit
接口同样也有clinit，但是与类型不同的是，它并不需要父类已经clinit，可以认为他们之间都是独立的，只有当父类被调用了，才会进行clinit。

## 只能有一个线程进行clinit
在多线程环境中，只能有一个线程进行clinit，会进行加锁。那么这就联想到了我们的双重检查锁那部分可以用类加载的方法来代替。

### 类加载实现双重检查锁
具体实现为，有一个static的内部类，其中有了这个static的单例对象，然后当第一次访问它的时候，需要对它初始化执行clinit，那么就可以保证只有一个线程执行。

## 什么时候触发初始化

### 1. new getstatic putstatic invokestatic
1. new对象
2. 读取静态字段
3. 执行静态方法

### 2. 反射
使用reflect包，也就是进行反射的时候，如果这个类型没有进行过初始化，就需要先触发初始化

### 3. 父类初始化
当初始化类的时候，父类没有初始化，就需要触发父类的初始化

### 4. 虚拟机main方法
虚拟机启动的时候，要指定一个主类，这个主类会首先被初始化

### 5. 动态语言
当使用JDK7新加入的动态语言支持时，如果static相关的方法句柄对应的类没有进行过初始化，那么就会触发其初始化。

### 6. 接口如果有default方法，那么接口要在实现类之前被初始化

## 几个特殊案例

1. static变量是随类初始化的，如果在子类中调用了父类的静态变量，也不会触发子类的初始化，只会触发父类的初始化
2. 数组类不会触发该类型的初始化，只会加载该类型
3. ConstantValue是不会触发初始化的，因为它是在连接-准备阶段就已经赋值到了ConstantValue当中，他就没必要再触发初始化了。