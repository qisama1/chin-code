# 不可达=回收？

判断为不可达 -》确定要进行回收，但是不一定就立即执行（判了死刑，但是没确定执行时间）

当第一次发现不可达以后，会进行第一次标记，随后进行筛选（筛选的条件是此对象是否有必要执行finalize()方法）

如果对象没有覆盖finalize()方法或者已经被掉用过了，就没有必要执行finalize()方法。

## F-Queue
如果认定为这个对象有必要执行finalize方法，那么就会加入到一个F-Queue队列当中，并在稍后由一条虚拟机自动建立、低优先级的Finalizer线程去执行这些对象的finalize方法。

并不会等待每一个对象的finalize方法都会执行完成（避免执行缓慢或者死循环导致垃圾回收系统的崩溃）

## finalize逃脱
那么在F-Queue里的对象会进行第二次标记，确定没有其他对象引用它，如果在中间这段时间有对象引用了它，那么它就会逃脱了。（现在没有引用，也许将来有引用）

## finalize 和 finally
首先这是两个不同的东西，finalize是方法的垃圾回收的方法，finally是跟随try-catch的语句，它是程序员手动的方式去对外部资源的一种清理。

我们在使用的时候finalize可以做的工作try-finally都可以做到。

## 什么是finalize方法
谈到finalize方法，它首先是在垃圾回收的第一次可达性分析的时候，把不可达的对象放入我们的F-Queue里头，然后执行他们的finalize方法。