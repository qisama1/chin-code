# 垃圾回收算法

## 标记清除算法
最早出现也是最基础的垃圾收集算法是-》“标记-清除”

### 思路：
标记出所有需要回收的对象，然后标记完成后，统一回收掉所有的对象，也可以反过来，标记存活了的对象然后统一回收未标记的。标记过程就是对象是否属于垃圾的判断过程。

### 缺点：
1. 执行效率不稳定，如果有大量的对象，而且其中大部分是需要被回收的，这是必须有大量的标记和清除的工作。会随着对象的增多而时间变长。
2. **内存碎片化，碎片太多会导致后续没有连续的大空间来分配对象，需要触发新的垃圾回收的工作**

## 标记复制算法

### 半区复制
将内存分为两块相等的范围，每次只用一半。然后把还活着的对象复制到另一块上面，然后再使用新的这一块。

缺点：如果大多数对象都是存活的，那么就会有大量的复制的开销。而且使用的空间只有一半，浪费太多

### Appel式回收（流行的
将新生代划分成Eden区和两块较小的Survivor区，每次只使用一块Eden区和一块Survivor区。发生垃圾搜集的时候，将Eden和Survivor中仍然存活的对象一次性复制到另一块Survivor空间上，然后直接清理掉Eden和已经用过的那块空间。

HotSpot的Eden和Survivor的比例是8:1

缺点：仍然是有复制的开销

## 标记整理算法
不使用额外的空间去移动复制，所有的操作都在同一块空间内。把标记好的对象重新整理到同一块空间内。

优点：空间利用率大

缺点：影响到了所有的对象，就导致“stop the world”