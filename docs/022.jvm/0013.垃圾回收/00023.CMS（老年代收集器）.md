# CMS(Concurrent Mark Sweep)老年代收集器

只有CMS基于标记清除算法！缺点就是空间的碎片化。

以获得最短回收停顿时间为目标的收集器。

## 标记清除过程
三个标记，一个清除
1. 初始标记：需要Stop the world，仅仅是标记一下GC ROOTS可以关联到的对象
2. 并发标记：从GC ROOTS遍历整个对象图，与用户线程同时进行。
3. 重新标记：需要stop the world修正并发标记的时候的导致标记变动会出现问题的情况。
4. 并发清除：清除掉标记阶段已经死亡的对象，由于不需要移动对象，所以这个过程也是与用户线程并发的。

## 缺点
空间碎片太多导致大对象无法分配-》老年代的FULL GC

1. CMS对处理器资源非常敏感，由于要占用线程进行垃圾收集，如果CPU核少，那么就会导致吞吐量低。他要占用（处理器核+3）/ 4个线程。如果核心数少于4那么就要考虑Serial Old。

2. CMS 无法处理浮动垃圾（区别于碎片空间）。浮动垃圾就是漏网之鱼，就是用户线程并发运行的时候产生的新垃圾是无法在本次的垃圾收集解决的。 当老年代预留的空间无法支持新对象的需求,当前的垃圾回收还没处理完，又出现一次垃圾回收，就会引发“Concurrent Mode Fail”，出现就必须stw，要引出Serial Old收集器进行收集。

## 如何避免Concurrent Mode Fail
可以设置多少次FullGC以后进行压缩，默认是0，也就是每次Full GC以后都会压缩。

设置老年代达到多少以后进行FullGC,默认是92%，这样就默认留了一些空间给大对象的分配。