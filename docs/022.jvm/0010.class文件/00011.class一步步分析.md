# class一步步分析

## 魔数
CA FE BA BE 

这里是标识这是一个class文件，这样去被虚拟机接受

## 次主版本号

### 次版本号
00 00 次版本号
### 主版本号
00 34 主版本号52->代表JVM8，这个东西是可以查表的

## 常量池

### 常量池计数器
表示常量池有多少东西，这里从索引0开始，但是索引0是单独留给一个空值为了给无法表示的东西的。如object的父类、匿名内部类的变量名和类名，所以会多一个常量。
### 常量池
根据常量池计数器中的数量可以遍历常量池。常量池中的各个常量首先是有一个tag，这个tag标识了常量的类型，然后就可以根据常量的类型往后遍历。

#### 常量池里放了什么东西
常量池其实就是把我们在.java文件中可以看到的所有的单词都给放入了里面，也就是我们的字面量。这里我们讲三个概念，字面量、符号引用、直接引用。

1. 字面量，字面量其实就是我们看到的东西，就是字符串。
2. 符号引用，指向了实际的类或者是属性，如package、全限定名、字段的名称和描述符、方法句柄和方法类型、动态调用点和动态常量。
3. 直接引用，在类加载过程中的解析这一步，会把符号引用给解析成直接引用，也就是把这些指向变成了真实的运行时内存区。

在jvm中加载一个类会经过如下过程
1. 找到这个类型的引用
2. 找到对应的class_info类型的常量
3. 找到utf8_info，就可以找到全限定名

我们的class文件只会保存文字信息，具体的内存分配他是完全未知的，这部分是jvm干的。

#### CONSTANT_CLASS_INFO
1. tag-代表这是CONSTANT_CLASS_INFO
2. name_index-指向一个具体的常量，代表了全限定名的Ljava.lang.String的utf8_info

#### CONSTANT_UTF8_INFO
1. tag-代表这是CONSTANT_UTF8_INFO
2. length-4字节长度，也正是这样所以String的最大长度就是65535-64KB大小。
3. byte-具体的字符内容

## 访问标志
这里的访问标志位就是各个位的二进制和，每个访问标志就是一位。
- ACC_PUBLIC
- ACC_FINAL
- ACC_PRIVATE
- ACC_SUPER
- ACC_INTERFACE
- ACC_ABSTRACT
- ACC_SYNTHETIC
- ACC_ANNOTATION

## 类索引和父类索引
分别指向第三个和第四个常量，就是告知一下当前类的全限定名和父类的全限定名

## 接口索引集合

### 接口索引集合计数器
标识了有多少个接口索引
### 接口索引集合
一个个遍历出接口索引的信息，也就是接口的全限定名

## 字段表

### 字段表计数器
字段表计数器标识了有多少个字段
### 字段表
一个个遍历出字段的信息
- 指向之前常量池中的常量，能标识出类型、字段名。
- 访问标志位
- 属性表；属性表主要就是可能有ConstantValue（static final就不走<clinit>的初始化方法，会在连接-准备阶段直接赋值到ConstantValue属性。

#### 如何区分类变量和实例遍历
ACC_STATIC标志位
#### 描述符
是用描述符来描述一个字段的类型的
如果是一个普通类型：
1. 基本类型-有它自己的代号
2. 对象-如Ljava.lang.String
3. 数组-[Ljava.lang.String;几维数组就有几维的[;例如int getNum(char[] c, int num)会被记为([CI)I

## 方法表
### 方法表计数器
方法表计数器就是标识了有多少个方法
### 方法表
方法表里面就有方法名、返回类型、code属性、LineNumberTable

ps：方法表里面肯定有init方法，就算你没有显式声明。
### 属性表
方法表里面也是有属性表的，有Code属性。
Code属性可以理解为写出了真正的JVM指令码和执行方法需要的细节内容。
1. 最大栈深度max_stack-操作数栈的最大深度
2. 最大局部变量表max_locals表示了局部变量表所需的空间；存放以slot为单位，一个slot最多存放32位的数据，像double、long这样的数据就需要两个slot。
3. 同时max_locals并不是所有的slot的累加，它会有预估的，他是同一时间所需用到的局部变量的最大空间。
4. 同时所有的方法都会有一个隐含的this参数，除了static方法，所以this也是需要空间的。
## 属性表
### 属性表计数器
记录有多少属性
### 属性表
属性表没有特别情况就会有一个SourceFile属性。