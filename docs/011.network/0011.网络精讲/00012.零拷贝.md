# 零拷贝
在网络传输中，由于像从网卡拷贝数据，和从socket缓冲发送数据到网卡，这些操作都只允许在内核态完成，所以需要进行：
1. 内核态到用户态的切换
2. 数据拷贝

那么其实也就是这两部分会耗费很多时间，那么零拷贝技术就从这两方面出发，看如何去减少耗时。

## read+write的文件传输
在有DMA（direct memory access）的帮助下，我们的网卡读取数据和CPU运行可以做到并行了。传统的网络传输是使用read+write,那么毫无质疑地需要进行，4次状态切换、4次数据拷贝。这效率太低了！！！
## mmap + write
mmap+write优化的部分在数据拷贝。它使用了一种共享内存，使得用户态和内核态共享了一部分的内存。这样一来就可以减少在read时期的数据拷贝。可以做到只需要4次状态切换（因为仍要调用mmap和write系统调用），3次数据拷贝。
## sendfile
sendfile就是可以指定原位置和指定位置，在这两个位置之间直接传输，不需要经过用户态，只有一个命令。

那么这样一来只需要2次状态切换，以及3次内存拷贝（因为仍然需要把缓存区的数据拷贝到socket缓冲区）。

### SG-DMA的加成
在有了SG-DMA以后，可以直接将读到缓冲区的数据写到网卡当中。这样一来实现了真正的零拷贝（数据没有经过倒卖），实现2次状态切换，2次内存拷贝。

## pagecache
在零拷贝中会使用到pagecache，他是一种内存缓存策略和mysql中的buffer poll类似。

因为我们知道磁盘读写到内存是很慢的，所以我们更期望是它就在内存中，我们读写就会很快。那么就会把一些磁盘中的文件保存在pagecache当中，并且pagecache支持预读，也就是读32bit的时候，会把接下来的32bit也读一些，这样可以有效提升缓存的命中率。

## 大文件传输
当有大文件传输的时候，pagecache就失效了，因为大文件占据了pagecache的空间，它几乎不会命中，而我们每次从磁盘里读取出数据来以后还需要去往pagecache拷贝一份，这样简直是浪费咯。所以大文件传输的时候就不该用使用pagecache的零拷贝。我们要使用直接读取的异步IO。

那么读写策略我们就已经得出:
1. 小文件使用零拷贝
2. 大文件使用异步IO+直接读取