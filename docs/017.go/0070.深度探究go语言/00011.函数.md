# 函数

总所周知，函数的调用是用栈来控制，而栈中的基本数据结构为栈帧

## 栈帧
golang的栈帧组成如下：
1. return address: 返回地址
2. caller's BP: 调用者的栈帧基址，占用一个指针的大小，用于将调用路径上所有的栈帧连成一个链表，方便回溯之类的操作，只在部分平台上有。函数通过将栈帧指针SP直接向下移动指定大小，一次性分配caller's SP, locals, args to callee等空间
3. locals：局部变量空间，占用若干机器字，用于存放函数的局部变量，根据函数的局部变量占用空间的大小来分配，没有局部变量的不分配
4. args to Callee:调用传参区域，会根据当前函数调用的所有函数中返回值加上参数所占用的最大空间来分配。当没有调用任何函数的时候，不需要分配该空间。
5. args from Caller 存储在 args to Callee中，也就是调用函数时，要负责存储这个函数使用到的参数
6. 综上，只有return address是一定存在的，其他三个空间都是需要分析的 。

## 调用约定

1. 返回值和参数都通过栈传递，对应的栈空间由调用者负责分配和释放
2. 返回值和参数在栈上的布局等价于两个struct，struct的起始地址按照机器字长对齐。

### Go1.17的优化
部分返回值和参数，会由寄存器来传递，而不使用栈

## 逃逸分析

### 什么是逃逸分析
当一个局部变量被传递出去了以后，它被看作了逃逸，逃逸的对象是不能分配在栈上的。
因为当函数调用完毕后，栈空间会被清除，这个对象指针就变成了悬挂指针。

所以我们要做逃逸分析，如果会逃逸的对象就要分配到堆上。

## Function Value

在Go语言中，函数也是一级公民（First class value），可以作为参数，返回值，变量来使用。

### Function Value是什么

结论：是一个函数指针，并且是一个二级指针。
fn首先指向一个函数指针，函数指针再指向代码段中的函数指令

## 闭包

有状态的函数，叫做闭包

闭包是要触发逃逸的，也就是在内层函数内使用的变量，藏在方法中被返回了出去
如下：
```go
func mc(n int) func() int {
	return func() int {
		return n
	}
}
```
1. 每次调用mc函数都会返回一个新的闭包；
2. 闭包中记住了参数n，所以它是由状态的。

### 闭包的状态保存在哪里！？
Go运行阶段会通过runtime.newobject()函数动态分配闭包对象。
```go
func newobject(typ *_type) unsafe.Pointer
```

编译器会识别出闭包这种模式，并为其创建一个新的结构体：
```go
struct {
    F uintptr
	  n int
}
```

在这个结构体里面存储了n的值（如有多个参数，那么都会记录），同时保存了目标函数的地址。

### 为什么是两级指针
正因为有闭包的存在，每个闭包中都需要有一个F，函数指针。如果只有一级指针的话，针对每一个闭包就都要新建一个函数指针，而二级指针直接共用即可。

### 区别闭包和逃逸
闭包并不等于逃逸

如果逃逸了的话就会调用newobject,而如果只是在闭包中返回，并不会调用到，而只是在闭包的结构体里存储。

### 调用闭包
在调用Function Value的时候总会通过DX寄存器去传值，不必区分是否为闭包，所以闭包函数的结构体指针就是在这时候传递的。

### 闭包的逃逸分析
如果闭包逃逸了，那么其捕获的对象也要跟着一起逃逸

闭包会倾向性的捕获值而不是指针，只有在值可能在闭包中（在闭包外则不会）发生改变的情况下，才会变为捕获地址
