# golang三色标记和GC混合写屏障机制

## Go V1.3之前的标记清除
1. 可达性分析
2. stop the world 
3. 标记不可达/可达对象
4. 回收
5. stop the world 结束


### 缺点
1. stw(main problem)
2. 扫描整个heap
3. 清除之后，heap之间会出现碎片
4. 先stop the world再进行回收

## GO V1.5三色标记法
黑白灰，快照，增量复制

1. GC ROOT（根节点）
2. 遍历Root Set，非递归形式，得到灰色节点
3. 遍历灰色， 遍历完以后灰色遍历为黑色
4. 再次遍历灰色，直到没有灰色节点（用3个集合来管理白色标记表，灰色标记表，黑色标记表）
5. 收集所有的白色对象

### 三色标记的STW
只在Root Set这块启动STW去保证Root节点不出错。

而后续出错只会有一种情况，而有两个条件：
1. 灰色对象向白色对象的引用消失
2. 黑色对象指向了白色对象

那么只要阻止这两个时间同时发生就行，那么就是有增量复制和原始快照就行

### 强三色不变式
强制性的不允许黑色对象引用白色对象

### 弱三色不变式
黑色对象可以引用白色，但是白色对象存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象

## Go V1.8混合写屏障

写屏障会影响创建对象的执行效率，那么在栈上不开启写屏障，只在堆上开启

### 插入写屏障
对象被引用的时候，触发的机制

A对象引用B对象的时候，B对象被标记成灰色

满足强三色不变式

#### 栈上
栈上个数是有限的，那么就在GC结束的时候，单独做一个STW，去做一个三色标记的遍历

### 删除屏障
一个对象被删除的时候，触发的机制

被删除的对象，如果自身为灰色或者白色，那么会被标记为灰色

### 三色标记的问题
只满足不会误删，可能一些垃圾会被放过，但是在下一轮GC也逃不掉

## 缺点

### 插入写屏障
结束时需要STW来重新扫描栈

### 删除写屏障
回收精度低，即使这个对象被删除了，那么最后一个指向它的指针也可以活过这一轮

## 混合写屏障整体操作
1. GC开始将在栈上的对象全部扫描，并标记为黑色（不再进行第二次扫描，无需STW）
2. GC期间，任何在栈上创建的新对象，都为黑色
3. 被删除的对象标记为灰色 // 强三色
4. 被添加的对象被标记为灰色 // 弱三色

**满足了变形的弱三色不变式**