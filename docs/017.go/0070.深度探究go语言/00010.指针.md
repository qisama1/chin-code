# 指针

## 解引用

通过指针去获取指针指向的内容（&ptr）称之为解引用

### 带来的问题
#### 1.空指针异常

空指针:地址值为0的指针

程序在解引用的时候，始终要保持不为空指针。如果出现空指针，go语言会panic
#### 2.野指针问题
野指针问题一般是由指针未初始化导致。

C语言中声明的变量需要显示的初始化，否则就是内存中上次遗留的随机值。
对于未初始化的指针变量而言，如果内存中的随机值非零，就会使指针指向一个随机的内存地址，而且会绕过代码中的空指针判断逻辑，导致内存访问的错误

go语言针对野指针问题，go语言的指针变量是有零值（初始值），为nil

代码中的空指针判断逻辑能够避免指针异常，从而解决野指针问题
#### 3.悬挂指针问题
悬挂指针问题：程序过早的释放了内存，而后续代码又对以及释放了的内存进行了访问，从而出现错误或异常

在C语言中，程序员需要手动的释放内存，所以会出现这类问题，而在go中，由于有着自动的内存管理，GC自行分析内存的回收和释放，所以避免了悬挂指针问题。

## 强制类型转换
go中的指针类型的强制转化，就是转换指针的含义，而不改变其内容。但是这是不安全的操作，不建议经常使用，要调用unsafe包去操作ptr。

## 指针运算
在C中，指针是可以通过加减操作去访问数组的下一位元素的，而go中是不允许的。

go中数组是需要指定长度，并且是值类型，与指针不再等价，也不支持指针运算，这些都是出于安全考虑

但是go中提供了slice，slice既有指向数组的指针，也保存了长度，某些场景下可以让slice做指针操作

## unsafe包
经典转化：
```go
  func convert(s []byte) string {
    return * (*string)(unsafe.Pointer(&s))
  }
```

slice和string的结构对比
1. slice: data,len,cap
2. string: data, len

这种方式的转化可以避免分配额外的空间，从而减少开销，但是也会带来风险。

因为根据go语言的设计思想，string是不可修改的，但是slice的元素则是可以修改的
通过这样获得的string，底层的byte数组是可能会被改变了，而破坏了go语言的设计思想。
如果不经意间改变了slice，就会导致程序的逻辑错误。
### 该不该用unsafe

#### 标准库还是keyword
本质上，unsafe其实是一个keyword，编译器直接可识别的，但是为了出于安全考虑，并没有让程序员直接使用，而是用unsafe来提醒程序员这是危险操作。

#### uintptr
uintptr只是一个数字，并不是指针，它不会增加对象的计数，如果错误的把它当做指针，会导致错误的GC

#### 内存对齐

struct的内存分配：
1. 从起始地址开始，各个成员按顺序分配
2. 对齐边界根据最大的对齐边界而定

那么struct的成员顺序就也变得有些重要了