# goroutine

## 程序的演进

- 最开始的读写队列，程序一边写，另一边读，是一个阻塞队列
- 后续有了批处理，等于有了一些buffer，把这个阻塞给解决了
- 再后来，有了进程这个概念，把程序资源分配在自己独立的空间进行管理
- 在有了多核cpu之后，慢慢有了线程这个概念，线程就是一个进程中拥有独立线程栈和pc，能够独立处理命令的单位，能够很好的适用于多核工作环境
- 线程之间也共用着进程的资源，所以线程的上下文切换的损耗也相对进程少很多

## 协程

在大量IO的情况下，为了性能，那么就要用更多的线程上下文切换去工作，在线程多了的情况下，这部分的损耗就不能忽略不计了。

所以考虑一个更轻量级的设计-**协程**

### 纤程

- 纤程：一种只有用户线程栈，没有内核栈，由用户态自主创建和销货，所以没有上下文的切换
- 由于之前大多是CPU密集型任务，而之前网关大多还是用阻塞式IO，线程也都挂起了，不会有机会去创建纤程

### IO多路复用
goroutine是集协程思想与IO多路复用为一体的思想

#### IO事件循环
像epoll这种的事件驱动的IO多路复用，它一直处于一个IO事件循环当中。

#### 结合
IO事件循环中，注册了许多的socket，那么把每个socket都对应上一个协程，这个协程单独的去处理这个IO事件。
对于整个程序来说就无感知的在内部完全实现了IO事件的完成

## GMP模型
GMP：goroutine,Machine,Processor

GMP简单来说就是Task，Worker，Resource的关系，G和P都是Go语言实现的抽象都更高的组件，而对于工作线程来说，Machine一词表述了它和具体的操作系统，平台密切相关，对具体平台的配置，特殊处理都在这一层实现

### 从GM到GMP

