# 普通索引or唯一索引

> 这讲提供了一个利用change buffer进行优化的思路~

## 查询过程的区别
使用普通索引和唯一索引的区别：

1. 插入的时候唯一索引是要把页取出来对比是否有重复的索引
2. 普通索引查询的时候，由于可能有多个结果，所以需要往后进行遍历，而唯一索引直接取出即可。

## change buffer
目前来看，第二条这样的在内存中的遍历，对效率的影响是很小的，那么关注点就要放在第一个区别。于是乎就对应上了change buffer；

change buffer的作用是把修改先记录在内存中，不直接写磁盘，等到合适的时候再merge。

当然change buffer只能用在普通索引上，因为唯一索引是必须要经过取出内存页然后进行唯一约束的确认的。所以有时在业务能够保证唯一性的前提下，我们需要考虑一下是不是该用change buffer来进行优化。

## change buffer的弊端
一个东西当然有优势也有弊端，change buffer的弊端就是，如果上一条刚记录下了change buffer，下一条就是查询这个记录，这其实不但不会提供效率，还会增加维护change buffer的代价。

那么这样看来，change buffer适合写多读少的场景咯。

## 一条插入记录的过程
首先，我们需要判断，当前需要插入的行所在的页在不在缓存当中。如果在缓存中，直接对缓存中的页进行操作，使它变成脏页。如果不在缓存当中，那么将放入change buffer里面，然后要记录redo log中！

## 一条查询记录的过程
查询的逻辑也是一样的，要先看要找到的页在不在内存当中，再看是不是change buffer中有，如果有的话要把磁盘中的数据取出，执行change buffer中的内容，取出数据，再刷盘回去。

## 小结
同样的，我们可以发现在innodb中很喜欢通过优化io对效率进行优化，redo log的WAL的这样优化写IO，MRR的优化读IO，这次的change buffer也是优化了读IO，不用再把磁盘中的内容读到内存中。