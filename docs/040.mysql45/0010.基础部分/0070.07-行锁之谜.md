# 行锁之谜

在很久之前，没有了解过Innodb的时候，我被各种八股文的行锁给唬住了。脱离八股深入了解之后反而轻松不少。

## 行锁的释放和获取

行锁顾名思义就是给一行记录上锁，上锁这个操作谁都会，而锁怎么获取、怎么释放、会不会导致死锁，这才是我们使用锁时需要关注的。

### 什么时候会触发行锁
我总结一句：当我们能对确定行进行资源获取的时候，行锁生效。

例如：
- select ... in share mode;
- select ... for update;
- update ...
- delete ...

如上操作都是行锁的获取，但是... 并不是你写了这行命令，你获取的一定就是行锁。
### 行锁的获取
Innodb下的行锁有这么几种：
1. Gap Lock
2. Record Lock
3. Next-key Lock

那么这是三种锁分别有着不同的作用。

#### Gap Lock 间隙锁
间隙锁的作用是锁住当前记录与旁边记录之间的范围，应用于非唯一索引。为什么呢？

非唯一索引是可以出现多个重复值的，那么此时如果允许插入相同的索引值，那么查询的时候就会出错，产生幻读。

#### Record Lock 记录锁
锁住当前记录，我对当前记录进行CRUD的时候，别人别再碰它了！

#### Next-Key Lock 
它可以说是Gap Lock + Record Lock的结合体，它实现了两者的功能，并应用于RR隔离级别以上。

并且它也是一个"能屈能伸"的锁，当应用于唯一索引或者主键索引的时候，它就会退化为一个Record Lock。

> 综上你可能页看出了，行锁进行的就是锁记录或者锁于旁边记录之间的范围。
### 行锁的释放
行锁的释放使用着两阶段锁模式~，用时获取，事务结束时才释放。那么这时候你就要当心出现死锁啦！
### 行锁失效
当然行锁是会失效的。试想你往一个未加索引的列key2，进行如下查询。
```mysql
select key2 from t where key2 = 1;
```
那么完蛋，你要进行一个事情叫做全表扫描了，此时给你用的不再是简简单单的锁一条记录。其实这换句话说就是你没办法知道会给多少行上锁，那么只好给全部的行都上锁了。

同理，当你索引失效要进行全表扫描的时候，自然上的是表锁。行锁失效某种意义下可以理解为索引失效。

#### 特殊的limit
在原文中提到了limit 1操作之后并不会对全表上锁。刚开始觉得是很神奇的事，但想想也确实，如果你能够确定你只需要对找到的第一条记录上锁，也就不需要进行全表的上锁了。似乎有时这也能成为一种优化，毕竟表级锁确实太重了。

## 死锁
好了，聊到现在应该对行锁有了一个较为清晰的认知，那么就不得不提使用锁时的注意事项了——死锁。

### 怎么会造成死锁
回忆很久以前的操作系统课，给了我们死锁的四个必要条件：
- 循环等待资源
- 不可抢占
- 保持请求资源
- 资源互斥

同时这也是破坏它的四个途径。

### 具体一点呢？
在Mysql里面具体一点就是如下两段代码：

A事务执行如下：
```sql
BEGIN;
select * from t where id = 1 for update;
select * from t where id = 2 for update;
COMMIT;
```
B事务同时执行如下：
```sql
Begin;
select * from t where id = 2 for update;
select * from t where id = 1 for update;
COMMIT;
```

那么很不巧，他们就触发了死锁。因为我们之前提到过，行锁是两阶段锁，它只在事务提交的时候才释放锁。

### 死锁了怎么办！
好说，如果你对自己及其自信，我的sql还能写出死锁？那你可以不用理会了。但大多数情况下，我们还是需要对系统有些保障的。

#### 超时终止
这也是最简单直观的方式，我一个语句执行太久了，不对劲，我发现了这个情况，我就把它终止了呗。同时这也就是破坏了保存资源请求这个条件，破坏了死锁。

但是这并不是那么简单的事，你得对你系统整体的执行时间有个很好的把控。否则你把没执行完的任务当成了死锁，这可就是个大乌龙了。这个超时的具体时间确实比较微妙。

#### 死锁检查

Innodb-用wait-for-graph等待图。看看目前的调用情况有无环出现，如果有环出现，那就说明有死锁。并会查看undo log把需要undo最少的那个事务回滚。这个做法貌似是从循环请求资源这个方向出发的，只要我不循环请求了，那岂不是没有死锁了。

这里顺便提一嘴，在面试中如果让我写个检查环的算法，我肯定毫不犹豫的选择spfa，有兴趣可以了解一下。

#### 死锁检查的问题
如果此时我只是多个事务在排队等待一个热点锁，并没有死锁出现，我就在这一个个的去检查有没有死锁，这么多的事务这是一个很大的消耗，我该怎么办。

- 还是自信，你关掉死锁检查就好，我代码没问题！
- 控制并发量，让当前并发量低一些。
- 改Mysql内部代码，这如果有大佬就让他去干吧，改一改什么时候才会触发死锁检查！
- 业务逻辑上改一些锁的争抢，比如10个修改数据合并在一个中进行汇总，这也是可行的。

## 总结
这一讲一步步的介绍了什么是行锁、行锁的获取和释放、死锁、出现了死锁怎么办。

思考题的解答，下面哪种删除10000行的思路是效率最高的：

1.delete from t limit 10000;
2.在一个连接中循环20次 delete from t limit 500;
3.在20个连接中 delete from t limit 500;

答案是第二种最优，原因是第一种我们会产生大事务，大事务其实是我们不愿意看到的。第三种20个连接同时删除，那当他们删除同一行的时候势必会竞争锁，所以说有时候多线程未必是好事。