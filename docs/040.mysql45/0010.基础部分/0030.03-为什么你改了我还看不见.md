# Day3-事务|为什么你改了我还看不见

> 这章是关于事务、事务隔离级别的

## 从一个最经典的例子开始聊事务

可以说基本上每个人接触到事务这个概念总是离不开一个转账的例子；
转账要经历从A账户转走和转入B账户之中，而保障这么一组操作不会出现纰漏的东西就是事务。

简单来说：事务就是能够保障一组操作要么同时成功要么同时失败的东西。

## ACID

提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

这一章标题就已经暗示了要说的是隔离性I。

## 为什么你改了我还看不见？

隔离性也是有隔离级别的，并不是每个隔离级别都是"看不见"
隔离级别分为：

1. ReadUncommited：读未提交
2. ReadCommited：读提交（RC
3. ReadRepeatable：可重复读（RR
4. Serializable：串行化

因为读过了许多关于隔离级别的文章，我最终将隔离级别归纳总结了一些。隔离级别的不同是源于多版本并发控制MVCC的，它的根本是快照读。
### 当前读和快照读

Innodb当中的读是有区分的，MVCC是基于快照读这么一个东西。有undo log提供出了一个数据是存在多个版本的情况，称之为快照。当前读顾名思义则就是直接去读页里面数据。

### MVCC
大名鼎鼎的MVCC，它是控制隔离级别的根本。它决定了我们当前读的是什么版本的数据。

只有RC和RR才会有MVCC，RC读的是当前最新版本的快照的数据，RR读的是事务开始的时候的快照的数据。读未提交则没有MVCC，它是实打实的去读数据。

所以现在我们出现了一个场景，有2个事务同时对一个数据进行修改，A事务在查询数据前，B事务提交了对数据的修改。此时：

- 读未提交：因为直接去读了，所以读到了最新修改的数据，甚至还没提交的数据它都能读到。
- RC：读最新版本的快照，它也读到了最新提交的快照的数据。
- RR：它是读事务开始的时候的快照，此时并不会读到B修改的这个值。
- 串行：串行顾名思义它会上锁让所有的操作看起来是串行执行的，并且是读的当前读，所以当两个事务想要对同一数据进行读写那是不可能的。

同时我想说所有的隔离级别都是有它存在的道理的，有他适合的场景，越高的隔离级别也就代表着越差的读写性能，这也是我常记在脑中的，性能和安全是需要找到一个平衡的。有些厂商认为RC就足够，有些厂商就认为RR就足够，甚至一些安全要求高的需要到串行级别，并没有一个标准答案。

## 事务的启动

1. 隐式
每一条单个的语句都会隐式的给你开启了一个事务
2. 显示
BEGIN 开启事务，COMMIT提交事务, ROLLBACK回滚事务
## 总结

这节我们了解到了Mysql的事务和事务隔离级别，了解到了快照读和当前读。知道Innodb在事务与事务直接是怎么处理隔离的。