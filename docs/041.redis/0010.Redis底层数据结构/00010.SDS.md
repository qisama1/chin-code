# 01-SDS（Simple Dynamic String）

> SDS是我们接触Redis的第一个基础数据结构，同时也是使用频繁的。

## SDS的使用
```redis
set key "hello world"
```
这句语句中就有两个字符串对象， key 和 "hello world"

## SDS是什么
SDS其实是redis中替代c语言中原有字符串类型的数据结构，为了解决一些c语言原生字符串做不到或做得不好的事情。

我们具体看看它的c语言代码：
```c
struct sdshdr {
    // 用于记录字符串长度
    int len;
    // 用于记录还剩下
    int free;
    // buf是真正记录字符的数组
    char buf[]
}
```

![image](./00010.SDS.md)


其实SDS就是一个redis作者为我们封装好的一个字符串"对象"，我们可以更方便、更高效操作字符串。

### 为什么SDS仍要以'\0'结尾
很简单的一个道理，因为redis仍然允许在c环境下，那么一些api可以直接使用的话，遵循c语言的规范也会更方便。

## SDS和原生字符串的区别

### 获取字符串长度
又是一个空间换时间的策略，通过记录一个len来去O(1)时间获取字符串场景。

### 杜绝缓冲区溢出
当年学C和C++的时候我就被分配空间，释放空间的操作给弄的头大，手动内存管理也是其一大特色，但是这样也会发生一件事就是缓冲区溢出，而丢失数据。当我们操作strcat的时候，并没有足够的空间，那么就会造成缓冲区溢出。

而我们SDS的用法我们知道了free，剩余的空间大小，就可以判断是不是可以放下这些字符。同时SDS这种数据结构给方法封装里起来，我们也不需要知道内部怎么实现而安全的使用提供的API。

### 减少重复分配内存空间的次数

#### 扩容
由于free这个属性的存在，我们为SDS预分配了一些空间，如果可以容纳得下的话，并不需要再一次的扩容，同时扩容是一种低效率的操作。

顺便，我们来聊聊扩容机制。在创建伊始，会为SDS分配字符串长度的空间，并且分配相同长度的free的空间，且free空间的最大容量为1MB，超过1MB以后也按1MB分配。

那么每次需要扩容的时候也是同样的，会分配和len一样大小的free，直到最大的1MB。
#### 惰性空间释放
惰性空间释放就是不立即把用不上的空间释放，而是用free属性来记录下来这些可用空间。

### 二进制安全
由于'\0'结尾的性质，如果字符串中间含有'\0'的话之后的数据都会被丢失，那么导致C语言本身只支持文本字符串，不支持二进制，它是二进制不安全的，这太恐怖了，在程序员的时间没有二进制那就完蛋了。

所以也必须要进行封装，SDS用len来判断是否结束，并提供安全的API。

### 支持C字符串函数
这个上面也提到过，这也是为什么要使用'\0'结尾的目的。