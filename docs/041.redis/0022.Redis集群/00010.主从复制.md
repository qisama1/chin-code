# 主从复制

当单机模式下最多支持10w的QPS，如果此时满足不了企业的需求，就需要上主从复制结构，单主节点，多从节点，主写读从的模式。

## 主从的设置
redis.conf中只需要让从节点中设置它的主节点即可。

replicaof ip port

其实这种模式看起来就只有一个问题，如何进行数据的同步。


## 主从复制下从节点会主动删除过期数据吗

### 删除消息的过程
1. 定时删除：定时删除是在主线程中进行的，会阻塞主线程，所以我们不期望它太长。所以如果大批量的key同时过期，可能就会导致这个现象。
2. 惰性删除：惰性删除可能会占用过多的内存，他是当get的时候发现这个key已经过期了。
### 会不会删除呢？
1. 3.2版本之前是会的，redis不会去判断是否过期。但是在3.2版本之后就会去判断是不是过期了，如果是过期的话就会删除消息并返回空值
2. 但是有个特别特别的问题，就是时间的问题。如果使用expire，expire设置过期时间，那么是从此开始后的多少时间过期，此时从节点同步过去就可能会有时延，导致读到过期数据。所以可以采用expireat, pexpireat, 使用unix时间戳。但是我们各个机器的时钟肯定还是会有问题的。

## 主从同步
首先，第一次启动的时候，会进行sync，也就是一次全量复制，全量复制就是要进行一次BGSAVE，然后将RDB文件传输过去，之后把缓冲区内的数据发送给从节点。之后以socket去传输后面的新写入命令。

### 重连
2.8版本后的更新，如果重连之后还要进行一次bgsave，那就太重量级了，所以需要进行优化。是进行psync。

首先，从节点之中会有主节点的run-id,同时有自己的偏移量。在重连以后会发送run-id和偏移量。run-id会与master节点进行对比，如果对比成功，会用偏移量与master中的环形存储进行对比，
如果在其中，就把在sliver和master偏移量之间的数据给发送过去。否则就要进行又一次的全量复制，bgsave。

流程：
1. 对比run-id，如果还是当前的主节点，那就继续判断，否则直接全量
2. 对比offset,offset之间的差距有没有超出我们的环形缓冲区的范围。如果没有，就可以把这段给增量发送给sliver。
3. 否则全量复制。

### 4.0后的更新psync2.0
因为如果出现了master节点的切换，上述2.8版本后的这样对比run-id的方式就失效了，仍然会进行全量复制。

出现了replid1和replid2的概念，当master进行替换后，replid1为自己的id，replid2为旧的id。借此去协助可能的增量替换。同时偏移量也会有两个。

## 为什么全量复制使用了RDB不用AOF
RDB的二进制压缩方式数独快，占用空间小。

## 主从复制方案有什么痛点
痛点就在于如果master挂了以后的处理方式，如果一个master挂掉了，需要人手工上去换master节点，同时更改sliver的master节点。

### 缺点
1. 内存瓶颈，由于主从节点都是一样的数据，那么会导致一定程度的内存的浪费。以后进行扩容的时候就很麻烦。
2. 只有一个master节点能写，吞吐量低。
3. 由集群去解决。