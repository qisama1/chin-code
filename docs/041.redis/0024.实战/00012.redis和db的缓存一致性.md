# redis和db的缓存一致性解决方案

## binlog方案

1. 更新db
2. 通过canal监听mysql的binlog，同时将数据同步到mq
3. 启动一个数据处理应用，消费mq数据进行加工
4. 将加工后的数据写入redis和es
5. 查询redis数据返回

### 优点
方案比较松耦合，适合大公司的高并发业务。
### 缺点
引入了多个中间件，比如canal，kafka，引入了数据处理程序（flink），比较复杂。

## 延时双删
1. 删除缓存
2. 更新db
3. 延迟sleep一下，3-5秒，3-5s也就是缓存写入的时间
4. 删除缓存


### 为什么要这么做
可能会存在，当我们删除缓存，去写db的这个过程中，有另外一个线程查询到了缓存为空，并且拿到了数据库的内容去更新缓存。这样会导致缓存为旧值而数据库为新值。

### 分布式锁
同时在缓存为空去访问db的时候，要加一个分布式锁。

### 缺点
这时候有个延时任务，如果系统是低延时的，这个就不太合适了。

## 定时任务方案

1. 更新db数据，同时写入到redis
2. 定时任务定时读取db的数据同步到redis
3. 查询数据的时候，如果缓存没有，同样也要有分布式锁让只有一个线程能访问db

### 缺点
可能对db的访问还是过多

## 自动或手动补偿
比如在秒杀场景下：

1. 先是写redis，再去写mysql
2. 为了防止这里出现mysql的写失败，那么我们会进行一个定时任务的补偿操作。对于表内和redis中数据不一致的情况，进行一个更新。